package cloud

import (
	"os"
	"strings"
	"testing"
)

func TestQueryForAsset(t *testing.T) {
	fQuery := FileQuery{
		TimeFrom: "2020-02-19T23:00:00.000Z",
		TimeTo:   "2020-02-20T19:00:00.000Z",
		Field:    "KVITEBJØRN",
		FileType: "XML",
	}
	if result, err := BuildQueryForAssetUsingCreated(fQuery); err != nil {
		t.Errorf("Failed in generation of asset query:%s", err.Error())
	} else {
		t.Logf("Generated asset query:%s", string(result))

	}
}

func TestQueryForAssetAndReportType(t *testing.T) {
	fQuery := FileQuery{
		TimeFrom:   "2020-02-19T23:00:00.000Z",
		TimeTo:     "2020-02-20T19:00:00.000Z",
		Field:      "KVITEBJØRN",
		FileType:   "XML",
		ReportType: "DDRML",
	}
	if result, err := BuildQueryForAssetUsingCreated(fQuery); err != nil {
		t.Errorf("Failed in generation of asset query:%s", err.Error())
	} else {
		if !strings.Contains(string(result), "DDRML") {
			t.Errorf("Template query coming back is missing DDRML reference")
		}
	}
}

//TestQueryForDDRMLPDFShouldResultInXML will test that if you try to build a query for a pdf ddrml file
//the query should ask for xml files instead as the pdf is generated by the system on the fly from the xml file reference
func TestQueryForDDRMLPDFShouldResultInXML(t *testing.T) {
	fQuery := FileQuery{
		TimeFrom:   "2020-02-19T23:00:00.000Z",
		TimeTo:     "2020-02-20T19:00:00.000Z",
		Field:      "KVITEBJØRN",
		FileType:   "PDF",
		ReportType: "DDRML",
	}
	if result, err := BuildQueryForAssetUsingCreated(fQuery); err != nil {
		t.Errorf("Failed in generation of asset query:%s", err.Error())
	} else {
		if !strings.Contains(string(result), "DDRML") || !strings.Contains(string(result), "XML") {
			t.Errorf("Template query coming back is missing DDRML or xml type reference")
		}
	}
	if result, err := BuildQueryForAssetUsingPeriod(fQuery); err != nil {
		t.Errorf("Failed in generation of asset query:%s", err.Error())
	} else {
		if !strings.Contains(string(result), "DDRML") || !strings.Contains(string(result), "XML") {
			t.Errorf("Template query coming back is missing DDRML or xml type reference")
		}
	}
}

func TestQueryForReportTypeNoAsset(t *testing.T) {
	fQuery := FileQuery{
		TimeFrom:   "2020-02-19T23:00:00.000Z",
		TimeTo:     "2020-02-20T19:00:00.000Z",
		FileType:   "XML",
		ReportType: "DDRML",
	}
	if result, err := BuildQueryForAssetUsingCreated(fQuery); err != nil {
		t.Errorf("Failed in generation of asset query:%s", err.Error())
	} else {
		t.Logf("Generated asset and report type query:%s", string(result))
		if !strings.Contains(string(result), "DDRML") {
			t.Errorf("Template query coming back is missing DDRML reference")
		}
	}
}

func TestQueryForReportTypeNoAssetAndUsingPeriod(t *testing.T) {
	fQuery := FileQuery{
		TimeFrom:   "2020-02-19T23:00:00.000Z",
		TimeTo:     "2020-02-20T19:00:00.000Z",
		FileType:   "XML",
		ReportType: "DDRML",
	}
	if result, err := BuildQueryForAssetUsingPeriod(fQuery); err != nil {
		t.Errorf("Failed in generation of asset query:%s", err.Error())
	} else {
		t.Logf("Generated asset and report type query:%s", string(result))
		if !strings.Contains(string(result), "DDRML") {
			t.Errorf("Template query coming back is missing DDRML reference")
		}
	}
}

func TestQueryForReportTypeWithAssetAndUsingPeriod(t *testing.T) {
	fQuery := FileQuery{
		TimeFrom:   "2020-02-19T23:00:00.000Z",
		TimeTo:     "2020-02-20T19:00:00.000Z",
		FileType:   "XML",
		ReportType: "DDRML",
		Field:      "BRAGE",
	}
	if result, err := BuildQueryForAssetUsingPeriod(fQuery); err != nil {
		t.Errorf("Failed in generation of asset query:%s", err.Error())
	} else {
		t.Logf("Generated asset and report type query:%s", string(result))
		if !strings.Contains(string(result), "DDRML") {
			t.Errorf("Template query coming back is missing DDRML reference")
		}
		if !strings.Contains(string(result), "BRAGE") {
			t.Errorf("Template query coming back is missing BRAGE reference")
		}
	}
}

func TestPostURLNotExisting(t *testing.T) {
	if _, _, err := RunGraphQueryForFiles("token", "https://ccasda", "key",
		[]byte("This is my raw request, sent as-is")); err == nil {
		t.Errorf("Resty post call should fail with invalid url did not...")
	} else {
		t.Logf("Got error back as should with invalid url:%s", err.Error())
	}
}

func TestPostURLThatIsNotCorrect(t *testing.T) {
	if _, _, err := RunGraphQueryForFiles("token", "https://epimno.azure-api.net/test/graph22",
		"key", []byte("This is my raw request, sent as-is")); err == nil {
		t.Errorf("Resty post call should fail with invalid url did not...")
	} else {
		t.Logf("Got error back as should with invalid url:%s", err.Error())
	}
}

func TestPostURLWithNoAuthAndSubscriptionKey(t *testing.T) {
	if _, _, err := RunGraphQueryForFiles("token", os.Getenv("AzureGraphUrl"), "", []byte("This is my raw request, sent as-is")); err == nil {
		t.Errorf("Resty post call should fail with invalid url did not...")
	} else {
		t.Logf("Got error back as should with invalid url:%s", err.Error())
	}
}

func TestPostURLWithNoAuth(t *testing.T) {
	if _, _, err := RunGraphQueryForFiles("token", os.Getenv("AzureGraphUrl"),
		os.Getenv("AzureSubscriptionKey"), []byte("This is my raw request, sent as-is")); err == nil {
		t.Errorf("Resty post call should fail with invalid url did not...")
	} else {
		t.Logf("Got error back as should with invalid url:%s", err.Error())
	}
}

func TestGraphQueryWithNoBody(t *testing.T) {
	var token string
	var err error
	//need to get the token first
	if token, err = GetValidToken(); err != nil {
		t.Errorf("Failed in test of authentication in run query for files with empty body, got error back instead of token:%s", err.Error())
	}
	if _, _, err := RunGraphQueryForFiles(token, os.Getenv("AzureGraphUrl"), os.Getenv("AzureSubscriptionKey"), []byte("")); err == nil {
		t.Errorf("Resty post call should fail with invalid url did not...")
	} else {
		t.Logf("Got error back as should with invalid url:%s", err.Error())
	}
}

func TestGraphQueryWithEmptyQuery(t *testing.T) {
	var token string
	var err error
	//need to get the token first
	if token, err = GetValidToken(); err != nil {
		t.Errorf("Failed in test of authentication in run query for files with empty body, got error back instead of token:%s", err.Error())
	}
	if _, _, err := RunGraphQueryForFiles(token, os.Getenv("AzureGraphUrl"), os.Getenv("AzureSubscriptionKey"),
		[]byte("{}")); err == nil {
		t.Errorf("Resty post call should fail with invalid url did not...")
	} else {
		t.Logf("Got error back as should with invalid url:%s", err.Error())
	}
}

func TestRunQueryForFilesUsingCreated(t *testing.T) {
	var token string
	var query []byte
	var err error
	fQuery := FileQuery{
		TimeFrom: "2020-02-25T23:00:00.000Z",
		TimeTo:   "2020-02-29T19:00:00.000Z",
		Field:    "ÅSGARD",
		FileType: "XML",
	}
	if query, err = BuildQueryForAssetUsingCreated(fQuery); err != nil {
		t.Errorf("Failed in generation of asset query:%s", err.Error())
		return
	}
	//need to get the token first
	if token, err = GetValidToken(); err != nil {
		t.Errorf("Failed in test of authentication in run query for files, got error back instead of token:%s", err.Error())
	}
	if _, _, err := RunGraphQueryForFiles(token, os.Getenv("AzureGraphUrl"), os.Getenv("AzureSubscriptionKey"), query); err != nil {
		t.Errorf("Resty post for files should not fail, failed with:%s", err.Error())
	} else {
		t.Logf("Got ok response back")
	}

}

func TestRunQueryForFilesUsingPeriod(t *testing.T) {
	var token string
	var query []byte
	var err error
	fQuery := FileQuery{
		TimeFrom: "2019-02-01T23:00:00.000Z",
		TimeTo:   "2019-02-05T19:00:00.000Z",
		Field:    "ÅSGARD",
		FileType: "XML",
	}
	if query, err = BuildQueryForAssetUsingPeriod(fQuery); err != nil {
		t.Errorf("Failed in generation of asset query:%s", err.Error())
		return
	}
	//need to get the token first
	if token, err = GetValidToken(); err != nil {
		t.Errorf("Failed in test of authentication in run query for files, got error back instead of token:%s", err.Error())
	}
	if _, _, err := RunGraphQueryForFiles(token, os.Getenv("AzureGraphUrl"), os.Getenv("AzureSubscriptionKey"), query); err != nil {
		t.Errorf("Resty post for files should not fail, failed with:%s", err.Error())
	} else {
		t.Logf("Got ok response back")
	}

}

func GetValidToken() (string, error) {

	return Authenticate()

}
